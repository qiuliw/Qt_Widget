音视频同步
    1. 视频同步音频
    2. 音频同步视频
    3. 参考时钟同步


音频所需的精度更大，间隔更易被感知。所以音频同步更合适。

**线程退出**
生产消费模型一端停止另一端休眠等待时，并不能知道另一端退出而去醒来检查退出条件，需要主动唤醒去检查退出条件。


**sleep太多**

**锁太多，不够原子化**

**头一次实战中遇到死锁问题**

不是问AI还真找不出来，多线程bug出现很随机。

在XVideoThread和XAudioThread的run()方法中，有以下操作顺序：

首先获取XDecodeThread的mtx_锁（通过Pop()方法）
然后调用decode_->Send()或decode_->Recv()，这会获取XDecode的mtx_锁
而在Clear()方法中，操作顺序是相反的：

首先获取XDecodeThread的mtx_锁
然后调用decode_->Clear()，这需要获取XDecode的mtx_锁
这就可能造成死锁：

run()方法获取了XDecodeThread的mtx_锁，等待XDecode的mtx_锁
Clear()方法获取了XDecode的mtx_锁，等待XDecodeThread的mtx_锁
解决方法是修改Clear()方法，避免在持有XDecodeThread的mtx_锁时去获取XDecode的mtx_锁：

主要需要锁的地方是访问自身管理的对象指针时，防止被删除后访问造成的非法访问。如果可以用智能指针代替或许可以免锁

多线程中，由于访问顺序不确定，死锁问题更加常见。
所以尽量避免一个线程可以持有**两个或以上**的锁，线程间使用消息传递机制而不是对共有对象进行锁操作来传递消息。

职责不明确和不使用消息传递导致对象被多个线程操作而多锁

## 缺点

1. 一个线程负责太多，没有缓冲，可能阻塞

解码线程和播放线程剥离。使用生产消费模型，使用无锁队列和消息队列机制，在消费后通知其去生产，生产满则休眠。避免解码阻塞影响播放。

抽离同步机制，使其支持暂停播放停止。协调各线程。


2. 使用锁去访问对象，保证对象的线程安全，但是一个对象就一个锁，锁的颗粒度太大。频繁获取锁也会导致性能下降。
一个线程持有多个对象和锁，可能造成**死锁**。

使用智能指针去保证对象的线程安全。也避免锁的使用



